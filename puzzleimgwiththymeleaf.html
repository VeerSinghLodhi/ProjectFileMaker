<!DOCTYPE html>
<html class="light" lang="en" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Epilogue:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
        rel="stylesheet" />

    <!-- TAILWIND CONFIGURATION -->
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#ed462c",
                        "background-light": "#f8f6f6",
                        "background-dark": "#221310",
                    },
                    fontFamily: {
                        "display": ["Epilogue", "sans-serif"]
                    },
                    borderRadius: {
                        "DEFAULT": "0.5rem",
                        "lg": "1rem",
                        "xl": "1.5rem",
                        "full": "9999px"
                    },
                },
            },
        }
    </script>

    <!-- CUSTOM STYLES -->
    <style>
        /* Glass morphism effect for header */
        .glass-header {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .dark .glass-header {
            background: rgba(34, 19, 16, 0.8);
        }

        /* Puzzle grid texture background */
        .puzzle-grid-texture {
            background-image: radial-gradient(#ed462c22 1px, transparent 1px);
            background-size: 40px 40px;
        }

        /* Gradient orbs with blur effect */
        .gradient-orb {
            filter: blur(80px);
            z-index: -1;
        }

        /* Ensure minimum height */
        body {
            min-height: max(884px, 100dvh);
        }

        /* Canvas styling to fill container */
        #canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Lightbox animations */
        #lightbox.active {
            display: flex !important;
            animation: fadeIn 0.3s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #lightboxImg {
            animation: zoomIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Popup animations */
        #messagePopup,
        #successPopup,
        #errorPopup {
            animation: fadeIn 0.3s ease;
        }

        #messagePopup>div,
        #successPopup>div,
        #errorPopup>div {
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* Success feedback slide in */
        #successFeedback.show {
            display: flex !important;
            animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 640px) {
            #canvas {
                width: 100% !important;
                height: auto !important;
            }
        }

        /* Prevent text selection on canvas interactions */
        #canvas {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Material icons fix */
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }

        /* Hover effects for buttons */
        button:active:not(:disabled) {
            transform: scale(0.98);
        }

        /* Loading state for submit button */
        #submitBtn.loading {
            opacity: 0.7;
            cursor: wait;
        }

        #submitBtn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Dynamic popup styles */
        .dynamic-popup {
            animation: fadeIn 0.3s ease;
        }

        .dynamic-popup>div {
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Reference thumbnail pulse effect on hover */
        #referenceThumb:hover .size-2 {
            animation: pulse 2s ease infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }
    </style>
</head>

<body class="bg-background-light dark:bg-background-dark font-display min-h-screen relative overflow-x-hidden">
    <!-- Decorative Gradient Orbs -->
    <div class="fixed top-[-10%] left-[-10%] w-[50%] h-[40%] bg-primary/10 rounded-full gradient-orb"></div>
    <div class="fixed bottom-[-10%] right-[-10%] w-[60%] h-[50%] bg-primary/5 rounded-full gradient-orb"></div>

    <!-- Sticky Header -->
    <header class="sticky top-0 z-50 glass-header border-b border-gray-100 dark:border-white/5">
        <div class="flex items-center p-4 justify-between max-w-md mx-auto">
            <a th:href="@{/user/op}"
                class="text-[#181211] dark:text-white flex size-12 shrink-0 items-center justify-start cursor-pointer">
                <span class="material-symbols-outlined text-2xl">arrow_back_ios</span>
            </a>
            <h2
                class="text-[#181211] dark:text-white text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center pr-12">
                Jigsaw Challenge
            </h2>
        </div>
    </header>

    <!-- General Message Popup -->
    <div th:if="${message}" id="messagePopup"
        class="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div
            class="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-sm mx-4 shadow-2xl border border-gray-200 dark:border-gray-700">
            <div class="flex items-center gap-4 mb-4">
                <div class="bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded-full p-2">
                    <span class="material-symbols-outlined text-2xl">info</span>
                </div>
                <h3 class="text-lg font-bold text-gray-900 dark:text-white">Notice</h3>
            </div>
            <p class="text-gray-600 dark:text-gray-300 mb-6" th:text="${message}"></p>
            <button onclick="closePopup('messagePopup')"
                class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-semibold transition-colors">
                OK
            </button>
        </div>
    </div>

    <!-- Success Message Popup -->
    <div th:if="${successMessage}" id="successPopup"
        class="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div
            class="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-sm mx-4 shadow-2xl border border-green-200 dark:border-green-700">
            <div class="flex items-center gap-4 mb-4">
                <div class="bg-green-100 dark:bg-green-900/30 text-green-600 dark:text-green-400 rounded-full p-2">
                    <span class="material-symbols-outlined text-2xl">check_circle</span>
                </div>
                <h3 class="text-lg font-bold text-gray-900 dark:text-white">Success!</h3>
            </div>
            <p class="text-gray-600 dark:text-gray-300 mb-6" th:text="${successMessage}"></p>
            <button onclick="closePopup('successPopup')"
                class="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-semibold transition-colors">
                OK
            </button>
        </div>
    </div>

    <!-- Error Message Popup -->
    <div th:if="${errorMessage}" id="errorPopup"
        class="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div
            class="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-sm mx-4 shadow-2xl border border-red-200 dark:border-red-700">
            <div class="flex items-center gap-4 mb-4">
                <div class="bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 rounded-full p-2">
                    <span class="material-symbols-outlined text-2xl">error</span>
                </div>
                <h3 class="text-lg font-bold text-gray-900 dark:text-white">Error</h3>
            </div>
            <p class="text-gray-600 dark:text-gray-300 mb-4" th:text="${errorMessage}"></p>
            <div class="bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 p-3 rounded mb-6">
                <p class="text-sm text-red-700 dark:text-red-300">Please try again or contact support if the issue
                    persists.</p>
            </div>
            <button onclick="closePopup('errorPopup')"
                class="w-full py-3 bg-red-600 hover:bg-red-700 text-white rounded-xl font-semibold transition-colors">
                OK
            </button>
        </div>
    </div>

    <main class="max-w-md mx-auto pb-32" th:if="${post != null}">
        <!-- User Context Badge -->
        <div class="flex items-center gap-3 px-4 pt-6 pb-2 justify-center">
            <a th:href="@{'/user/dashboard/' + ${postOwnerId}}"
                class="flex items-center gap-2 bg-white/80 dark:bg-white/10 backdrop-blur-md px-3 py-1.5 rounded-full shadow-sm border border-white/20 hover:bg-white/90 dark:hover:bg-white/20 transition-colors">
                <div class="bg-center bg-no-repeat aspect-square bg-cover rounded-full h-6 w-6"
                    th:style="'background-image: url(' + @{'/user/post/photo/' + ${post.postId}} + ');'">
                </div>
                <p class="text-[#181211] dark:text-white text-xs font-semibold leading-normal"
                    th:text="'@' + ${postOwnerName}">@username</p>
                <div class="flex size-4 items-center justify-center">
                    <div class="size-2 rounded-full bg-[#078809]"></div>
                </div>
            </a>
        </div>

        <!-- Puzzle Area Container -->
        <div class="relative p-4 @container">
            <!-- Reference Image Thumbnail (Top Right Overlay) -->
            <div class="absolute top-8 right-8 z-10 group cursor-pointer" id="referenceThumb">
                <div
                    class="relative w-20 h-20 rounded-lg overflow-hidden border-2 border-white shadow-lg ring-1 ring-black/5">
                    <div
                        class="absolute inset-0 bg-black/20 group-hover:bg-black/0 transition-colors flex items-center justify-center">
                        <span class="material-symbols-outlined text-white drop-shadow-md">zoom_in</span>
                    </div>
                    <div class="w-full h-full bg-center bg-no-repeat bg-cover" id="referenceThumbnail"
                        th:style="'background-image: url(' + @{'/user/post/photo/' + ${post.postId}} + ');'">
                    </div>
                </div>
            </div>

            <!-- Puzzle Canvas Container -->
            <div
                class="flex flex-col items-center justify-center rounded-xl bg-white/40 dark:bg-white/5 border border-white/60 dark:border-white/10 aspect-square w-full shadow-xl relative overflow-hidden puzzle-grid-texture">
                <canvas id="canvas" width="480" height="480" class="w-full h-full touch-none"></canvas>
            </div>
        </div>

        <!-- Success Feedback (Hidden by default, shown via JS) -->
        <div id="successFeedback"
            class="px-6 py-4 mx-4 mb-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-xl flex items-center gap-4 hidden">
            <div class="bg-green-500 text-white rounded-full p-1 flex items-center justify-center">
                <span class="material-symbols-outlined text-lg">check</span>
            </div>
            <div>
                <p class="text-green-800 dark:text-green-200 text-sm font-bold">Perfect Match!</p>
                <p class="text-green-700/80 dark:text-green-300/80 text-xs">Pieces are connecting beautifully!</p>
            </div>
        </div>
    </main>

    <!-- Bottom Controls Area -->
    <div class="fixed bottom-0 left-0 right-0 p-4 pb-8 glass-header border-t border-gray-100 dark:border-white/5"
        th:if="${post != null}">
        <div class="max-w-md mx-auto flex items-center gap-3">
            <a th:href="@{/user/op}"
                class="flex items-center justify-center size-14 shrink-0 rounded-xl bg-gray-100 dark:bg-white/10 text-[#181211] dark:text-white hover:bg-gray-200 dark:hover:bg-white/20 transition-colors">
                <span class="material-symbols-outlined">skip_next</span>
            </a>

            <form th:action="@{/user/solved}" method="post" id="puzzleForm" class="flex-1">
                <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
                <button type="button" id="submitBtn"
                    class="w-full flex cursor-pointer items-center justify-center overflow-hidden rounded-xl h-14 px-5 bg-gradient-to-r from-primary to-[#ff5a43] text-white text-base font-bold leading-normal tracking-[0.015em] shadow-lg shadow-primary/25 hover:shadow-xl hover:shadow-primary/30 transition-all">
                    <span class="truncate">Submit Solution</span>
                </button>
            </form>

            <button id="solveBtn"
                class="flex-1 flex min-w-[100px] cursor-pointer items-center justify-center overflow-hidden rounded-xl h-14 px-5 border-2 border-primary/30 text-primary text-base font-bold leading-normal tracking-[0.015em] bg-white/50 dark:bg-transparent hover:bg-white/70 dark:hover:bg-white/10 transition-colors">
                <span class="truncate">Auto Solve</span>
            </button>
        </div>
    </div>

    <!-- Lightbox for Reference Image -->
    <div id="lightbox"
        class="hidden fixed inset-0 z-[9998] bg-black/90 items-center justify-center opacity-0 transition-opacity">
        <button class="absolute top-4 right-4 text-white hover:bg-white/10 rounded-full p-2 transition-colors"
            id="closeLightbox">
            <span class="material-symbols-outlined text-4xl">close</span>
        </button>
        <img id="lightboxImg" class="max-w-[90vw] max-h-[90vh] rounded-xl shadow-2xl" alt="Reference Image">
    </div>

    <script th:inline="javascript">
        // ============================================
        // GET EVENT COORDINATES (MOUSE OR TOUCH)
        // ============================================

        function getEventCoords(e) {
            if (!canvas) return { x: 0, y: 0 };

            const r = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return {
                x: (clientX - r.left) * scaleX,
                y: (clientY - r.top) * scaleY
            };
        }

        // ============================================
        // GET PIECE AT SPECIFIC POINT USING HIT DETECTION
        // ============================================

        function getPieceAtPoint(x, y) {
            if (!hitCtx) return null;

            const pixel = hitCtx.getImageData(x, y, 1, 1).data;
            const color = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;

            for (let i = pieces.length - 1; i >= 0; i--) {
                if (pieces[i].hitColor === color) {
                    return pieces[i];
                }
            }
            return null;
        }

        // ============================================
        // HANDLE START OF DRAG (MOUSE DOWN / TOUCH START)
        // ============================================

        function handleStart(e) {
            const coords = getEventCoords(e);
            const piece = getPieceAtPoint(coords.x, coords.y);

            if (piece) {
                selected = piece;
                activeGroupId = piece.groupId;
                offsetX = coords.x - piece.x;
                offsetY = coords.y - piece.y;

                const fullGroup = groups[piece.groupId];
                const connectedPieces = getConnectedPieces(piece, fullGroup);

                selected.connectedPieces = connectedPieces;

                // Move selected pieces to end of array (render on top)
                pieces = pieces.filter(p => !connectedPieces.includes(p));
                pieces = pieces.concat(connectedPieces);

                draw();
            }
        }

        // ============================================
        // HANDLE DRAG MOVEMENT (MOUSE MOVE / TOUCH MOVE)
        // ============================================

        function handleMove(e) {
            if (!selected || !canvas) return;
            e.preventDefault();

            const coords = getEventCoords(e);
            const newX = coords.x - offsetX;
            const newY = coords.y - offsetY;

            const dx = newX - selected.x;
            const dy = newY - selected.y;

            const connectedPieces = selected.connectedPieces;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // Calculate bounding box of connected pieces
            connectedPieces.forEach(p => {
                const hitW = p.w + RENDER_BLEED * 2;
                const hitH = p.h + RENDER_BLEED * 2;
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x + hitW);
                maxY = Math.max(maxY, p.y + hitH);
            });

            const newMinX = minX + dx;
            const newMinY = minY + dy;
            const newMaxX = maxX + dx;
            const newMaxY = maxY + dy;

            let constrainedDx = dx;
            let constrainedDy = dy;

            // Constrain movement within canvas bounds
            if (newMinX < 0) constrainedDx = -minX;
            if (newMinY < 0) constrainedDy = -minY;
            if (newMaxX > canvas.width) constrainedDx = canvas.width - maxX;
            if (newMaxY > canvas.height) constrainedDy = canvas.height - maxY;

            // Move all connected pieces together
            connectedPieces.forEach(p => {
                p.x += constrainedDx;
                p.y += constrainedDy;
            });

            draw();
        }

        // ============================================
        // HANDLE END OF DRAG (MOUSE UP / TOUCH END)
        // ============================================

        function handleEnd(e) {
            if (selected) trySnap(selected);
            selected = null;
            activeGroupId = null;
            draw();
        }

        // ============================================
        // ATTACH EVENT LISTENERS
        // ============================================

        if (canvas) {
            // MOUSE EVENT LISTENERS
            canvas.addEventListener("mousedown", handleStart);
            canvas.addEventListener("mousemove", handleMove);
            canvas.addEventListener("mouseup", handleEnd);

            // TOUCH EVENT LISTENERS
            canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                handleStart(e);
            }, { passive: false });

            canvas.addEventListener("touchmove", handleMove, { passive: false });
            canvas.addEventListener("touchend", handleEnd, { passive: false });
        }

        // ============================================
        // AUTO SOLVE BUTTON
        // ============================================

        const solveBtn = document.getElementById("solveBtn");
        if (solveBtn) {
            solveBtn.addEventListener('click', () => {
                pieces.forEach(p => {
                    p.x = p.correctX;
                    p.y = p.correctY;
                });
                draw();
                showCustomPopup("Puzzle solved automatically! ðŸŽ‰", "success");
            });
        }

        // ============================================
        // SUBMIT SOLUTION BUTTON WITH VALIDATION
        // ============================================

        const submitBtn = document.getElementById("submitBtn");
        if (submitBtn) {
            submitBtn.addEventListener('click', () => {
                let solved = true;

                // Check if all pieces are in correct position relative to each other
                for (let i = 0; i < pieces.length; i++) {
                    for (let j = i + 1; j < pieces.length; j++) {
                        const p1 = pieces[i];
                        const p2 = pieces[j];

                        const expectedDx = p2.correctX - p1.correctX;
                        const expectedDy = p2.correctY - p1.correctY;

                        const actualDx = p2.x - p1.x;
                        const actualDy = p2.y - p1.y;

                        // Allow 5 pixel tolerance
                        if (
                            Math.abs(actualDx - expectedDx) > 5 ||
                            Math.abs(actualDy - expectedDy) > 5
                        ) {
                            solved = false;
                            break;
                        }
                    }
                    if (!solved) break;
                }

                if (!solved) {
                    // Show error popup
                    showCustomPopup("Almost there! Keep going ðŸ§©", "error");
                } else {
                    // Puzzle is solved - add loading state and submit
                    submitBtn.classList.add('loading');
                    submitBtn.disabled = true;

                    // Submit the form
                    const puzzleForm = document.getElementById("puzzleForm");
                    if (puzzleForm) {
                        puzzleForm.submit();
                    }
                }
            });
        }

        // ============================================
        // RESPONSIVE CANVAS SIZING
        // ============================================

        function resizeCanvas() {
            if (!canvas) return;

            const container = canvas.parentElement;
            if (container) {
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                // Maintain aspect ratio
                const size = Math.min(containerWidth, containerHeight);
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
            }
        }

        // Resize on window resize with debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 150);
        });

        // Initial resize
        document.addEventListener('DOMContentLoaded', resizeCanvas);

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        document.addEventListener('keydown', (e) => {
            // Press 'S' to auto-solve (for testing)
            if (e.key === 's' || e.key === 'S') {
                if (solveBtn && e.ctrlKey) {
                    e.preventDefault();
                    solveBtn.click();
                }
            }

            // Press Enter to submit
            if (e.key === 'Enter' && submitBtn) {
                e.preventDefault();
                submitBtn.click();
            }
        });

        console.log('Puzzle game initialized successfully! ðŸ§©');
    </script>
</body>

</html>